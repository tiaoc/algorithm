package com.leetcode;

import java.util.Arrays;

public class leetcode5892 {
    //取出的堆 什么时候被3整除，就是外堆任取一数都能保证被3整除
    //不被3整除，就必须余3为1或2.
    //如果存在3的倍数
    //被3整除就输，肯定不能拿3，但是3的倍数可以后拿。数字其实就是012这3种
    //如果现在是1，队伍里只剩下2就输了。3的倍数需要考虑个数
    //先拿1或者2取决于队伍里2的个数，如果拿1，再拿1就可以拿2，
    //2是第二步，
    //2---2或0
    //1---1或0
    //2转移到1，1转移到2，0不转移
    //不转移对自己有利吗
    //多少个1多少个2多少个0
    //取1或者取2，是alice的权利，如果取12都不赢就输了
    //其实就是判断取1或2能不能赢
    //取1获胜的条件-
    //要赢，取到最后一个不能是整除
    //取到中间不能没数拿，同性相吸，异性相斥，那么找同性对是自己的权利
    //0是奇偶分配的权利，找到没有同性对的数字（1和2中，然后选择，都不能让对手选到没数可选（只能选异性）就输了）
    //判断0的个数 12同性对的个数
    // 1 1 1 必输 1 1 0 必赢 1 0 1 必输 1 0 0必赢
    //赢010/100/110/     输101/011/111/000/001
    public static void main(String[] args) {
        int[] stones=new int[]{3,18,10,12,14,19,19};
        System.out.println(new leetcode5892().stoneGameIX(stones));
        System.out.println(new leetcode5892().stoneGameIX(new int[]{20,3,20,17,2,12,15,17,4}));
    }
    //3可以余2
    //1 2不行 1--- 0 1 2   2---0 1 2
    public boolean stoneGameIX(int[] stones) {
        long[]count=new long[3];
        for(int num:stones){
            count[num%3]++;
        }
        if(count[0]%2==0&&count[1]*count[2]>0){
            return true;
        }
        if(count[0]%2==1&&Math.abs(count[1]-count[2])>=3){
            return true;
        }
        return false;
    }
}

//想要赢，就必须在中间用尽选择，选完后只剩下互补的选择给对手，而且不能不留下选择，存在这样的情况吗
//1和2的转化有化简方式吗，不能自己直接选3
//100分两种情况，拿了1之后，没有选择就输，有选择就赢，什么时候有选择

//转换一次交换一次选择权，直接影响胜负，并且影响了数字变动。
// 0 100 100
//153  1 1 1
// 143


//两个2 等于1个1 两个1等于1个2
//如何消除，再加上turn，只计算turn？

//20,3,20,17,2,12,15,17,4    010 可以为true